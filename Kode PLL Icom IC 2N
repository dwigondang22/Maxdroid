
//*Program ICOM IC-2N/
// *Dibuat dari basic program Motorolla-Pecco
// *Kebutuhan pin untuk mengontrol PLL adalh 12 pin digital 

#include <avr/pgmspace.h>
#include <Bounce2.h>
#include <Wire.h>
#include <LCD_I2C.h>
#include <EEPROM.h>
#include <pcf8574.h>

// Inisialisasi LCD
LCD_I2C lcd(0x27, 16, 2);  // Alamat I2C 0x27, 16x2 LCD
//Rotary Encoder 
#define encoder0PinCLK  2 //encoder
#define encoder0PinDT  3 //encoder
#define encoder0PinSW 4 // for encoder  press
Bounce debouncerCLK = Bounce(); 
Bounce debouncerDT = Bounce(); 
Bounce debouncerSW = Bounce ();
Bounce debouncerTB = Bounce ();
Bounce debouncerTB1 = Bounce ();
Bounce debouncerTB2 = Bounce ();
//Kontrol PLL (RATUSAN, PULUHAN, SATUAN)
#define ratusan1  A0    
#define ratusan2  A1  
#define ratusan4  A2    
#define ratusan8  A3    
#define puluhan1  0   
#define puluhan2  1   
#define puluhan4  2   
#define puluhan8  3   
#define satuan1  4    
#define satuan2 5   
#define satuan4 6   
#define satuan8 7 
#define TOMBOL 9
#define TOMBOL1 10
#define TOMBOL2 8
#define MAX_MEM 63
unsigned long int FMem[]={1430001,1430201,1439801,1440601,1450001,1461601,1468001,1471601,1480601,1490801,1429001,1429001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001};
unsigned long Frq=145000;
unsigned long int NewMemToSave = 0;
int FOffset[MAX_MEM];
long FrqFinal;
boolean SaveVfo = 0;
//PCF Eksternal
PCF8574 io (0x20); //Mengenali eksternal I/O PCF 8574 8 pin 
//Perangkat Tambahan
int digitPilihan =-1;
bool lastButtonState = HIGH;
int lastMenue = -1;
unsigned long time1;
int EncDo=1;// this changes when you turn the encoder +1 or -1
long Step=10;// vfo step size
const long MinStep = 10;  
const long MaxStep = 100;  
float Ctcss = 67.0; 
int Ctcssindex = 0; // Mulai dari 67.0 Hz 
const int CtcssPin = 5;
boolean PlSq=0;// ctcss or cor 0 ctcss 1 cor
int Menue=0; // changes when you scroll the menue
boolean Mode=1; // 0= vfo 1=memory
int Mem=0;// first memory when turn on
boolean Curspress=0;// knows when the encoder was pressed
bool Refresh=false;
int Shift=0;// repeater shift register 0= simp// <0 -// >0 +
int CursPos=0;// rotary encoder change
int Tmp=0;// nice to have
boolean Tx=0;// when the rig is in tx it is 0
boolean TxOld=0;// can do without it read insted of reg leave for now....
boolean Rx=0;//indicates the Rx on
boolean Power=0; //output power
unsigned long lastPressTime = 0;  // Waktu terakhir tombol SW ditekan
bool isPressingSW = false;
long Offset = 300;  // Default Offset 300 kHz
long MinOffset = 300;  // Minimum Offset 300 kHz
long MaxOffset = 8990;  // Maximum Offset 8990 kHz
//Fungsi Scan Frekuensi
boolean Scan=0; // temp test scan function
int MemBeforeScan = 0;// return to this frequency when stoping the scan without ptt
// Bar signal untuk kece2an 
int level=0;
int lastLevel=-1;
unsigned long previousMillis = 0;
const long riseInterval = 30;
const long fallInterval = 50;
byte bar1[8] = { B00000, B00000, B00000, B00000, B00000, B11111, B11111, B11111 }; 
byte bar2[8] = { B00000, B00000, B00000, B00000, B11111, B11111, B11111, B11111 }; 
byte bar3[8] = { B00000, B00000, B00000, B11111, B11111, B11111, B11111, B11111 }; 
byte bar4[8] = { B00000, B00000, B11111, B11111, B11111, B11111, B11111, B11111 }; 
byte bar5[8] = { B00000, B11111, B11111, B11111, B11111, B11111, B11111, B11111 };
byte bar6[8] = { B11111, B11111, B11111, B11111, B11111, B11111, B11111, B11111 }; 
//logo Antenna
byte antenna[8] = {B11111,B10001,B01010,B00100,B00100,B00100,B00100,B00100,};
//kursor penunjuk
byte kursor[8] = { B11111, B11111, B00000, B00000, B00000, B00000, B00000, B00000 }; 
//logo tone
byte nada[8] = { B00000, B00010, B00011, B00010, B00010, B01110, B11110, B01100};
// Fungsi untuk menyimpan data ke EEPROM
void saveToEEPROM() {
  if(EEPROM[0] == 255 && EEPROM[1] == 255 && EEPROM[2] == 255 && EEPROM[3] == 255)
 {
  // Simpan data FMem ke EEPROM
  EEPROM.put(0, FMem);  // Menyimpan data ke alamat 0
  // Verifikasi apakah data benar-benar tersimpan
  EEPROM.put(sizeof(FMem), FOffset);
 }else{
  // Membaca kembali data
  EEPROM.get (0,FMem);
  EEPROM.get (sizeof(FMem), FOffset);
}
}

void setup()
{
  Serial.begin (9600);
 //PIN-PIN UNTUK KONTROL
 //A.Pin Rotary Encoder
  pinMode(encoder0PinCLK, INPUT); // for encoder turn
  pinMode(encoder0PinDT, INPUT); // for encoder turn 2
  pinMode(encoder0PinSW, INPUT_PULLUP); // for encoder  press
 //B. Pin Kontrol PLL
  pinMode (ratusan1, OUTPUT);
  pinMode (ratusan2, OUTPUT);
  pinMode (ratusan4, OUTPUT);
  pinMode (ratusan8, OUTPUT);
  pinMode (io, puluhan1, OUTPUT);
  pinMode (io, puluhan2, OUTPUT);
  pinMode (io, puluhan4, OUTPUT);
  pinMode (io, puluhan8, OUTPUT);
  pinMode (io, satuan1, OUTPUT);
  pinMode (io, satuan2, OUTPUT);
  pinMode (io, satuan4, OUTPUT);
  pinMode (io, satuan8, OUTPUT);
 //C. Pin Kontrol Lainnya
  pinMode (6, INPUT); //RX
  pinMode (7, INPUT); //TX
  pinMode(A6, INPUT);  // untuk analog bar signal 
  pinMode(A4, OUTPUT); // pin SDA LCD
  pinMode(A5, OUTPUT); // pin SCL LCD
  pinMode (11, OUTPUT); //PIN untuk Tone atau CTCSS
  pinMode (5, OUTPUT); //MUTE RX
  pinMode(12, OUTPUT);  // Kontrol Power ke Boster (High/Low)
  pinMode(TOMBOL2, INPUT_PULLUP);
  pinMode(TOMBOL, INPUT_PULLUP);
  pinMode(TOMBOL1, INPUT_PULLUP);
  //Debouncer untuk mencegah lag pada Rotary
  debouncerCLK.attach(encoder0PinCLK);
  debouncerCLK.interval(5);
  debouncerDT.attach(encoder0PinDT);
  debouncerDT.interval(5);
  debouncerSW.attach(encoder0PinSW);
  debouncerSW.interval(5);
  debouncerTB.attach(TOMBOL);
  debouncerTB.interval(5);
  debouncerTB1.attach(TOMBOL1);
  debouncerTB1.interval(5);
  debouncerTB2.attach(TOMBOL2);
  debouncerTB2.interval(5);
 saveToEEPROM(); // Mengaktifkan fungsi EEPROM
 lcd.begin(); // Memulai koneksi ke LCD 
 Wire.begin(); //Menyambungkan beberapa perangkat
 lcd.backlight();  // Mengaktifkan backlight LCD
 lcd.setCursor(2, 0);
lcd.print("ARDUICOM-2N");
lcd.setCursor (3,1);
lcd.print("VERSI 1.0");
delay(1500);

lcd.clear();  // Bersihkan layar sebelum menampilkan teks selanjutnya
lcd.setCursor(2, 0);
lcd.print("DEVELOPED BY ");

lcd.setCursor(3, 1);
lcd.print("<CAK-PECO>");
delay(1500);

lcd.setCursor(3, 1);
lcd.print("<Chat-GPT>"); // beberapa kode penyempurnaan berdiskusi dengan openAI 
delay(1500);

lcd.clear();  // Bersihkan layar
  lcd.createChar(0, bar1);
  lcd.createChar(1, bar2);
  lcd.createChar(2, bar3);
  lcd.createChar(3, bar4);
  lcd.createChar(4, bar5);
  lcd.createChar(5, bar6);
  lcd.createChar(6, antenna);
  lcd.createChar(7, kursor);
  lcd.createChar(8, nada);
   for (int i = 0; i < 8; i++) {
    pinMode(io, i, OUTPUT);
    digitalWrite(io, i, LOW); // Pastikan semua pin LOW saat awal
  }
}
void set_pll (unsigned long int rx_hz)
{
   unsigned long hz = rx_hz + (!Tx * Shift * Offset );
   if (hz < 141000) hz = 141000;
   if (hz > 149990) hz = 149990;
   unsigned long tempHz = hz;
   unsigned long int Frq1=hz;
   unsigned int n = (tempHz /= 10) % 1000; // Ambil hanya 3 digit terakhir setelah "14"
    int ratusan = (n / 100) % 10; // Ambil angka ratusan
    int puluhan = (n / 10) % 10;  // Ambil angka puluhan
    int satuan  = n % 10;         // Ambil angka satuan

   // Atur nilai ratusan ke output
    digitalWrite(ratusan1, (ratusan >> 0) & 1);
    digitalWrite(ratusan2, (ratusan >> 1) & 1);
    digitalWrite(ratusan4, (ratusan >> 2) & 1);
    digitalWrite(ratusan8, (ratusan >> 3) & 1);

    // Atur nilai puluhan ke output
    digitalWrite(io, puluhan1, (puluhan >> 0) & 1);
    digitalWrite(io, puluhan2, (puluhan >> 1) & 1);
    digitalWrite(io, puluhan4, (puluhan >> 2) & 1);
    digitalWrite(io, puluhan8, (puluhan >> 3) & 1);

    // Atur nilai satuan ke output
    digitalWrite(io, satuan1, (satuan >> 0) & 1);
    digitalWrite(io, satuan2, (satuan >> 1) & 1);
    digitalWrite(io, satuan4, (satuan >> 2) & 1);
    digitalWrite(io, satuan8, (satuan >> 3) & 1);

}
void cursorpress()
{
  Curspress=1;
  if (Mode==1 && Menue==1)
  {
    Menue=8;
    return;
  }
  if(Mode==0 && Menue==0 && NewMemToSave != 0)
  {
    SaveVfo = 0;
    Menue = 7;
    return;
  }
  if(Menue == 7 && Mode == 0)
  {
    Menue = 0;
    Mode = 1;
    if(SaveVfo)
    {
      FMem[Mem] =  NewMemToSave;
      FOffset[Mem] = Offset;
      EEPROM.put(0, FMem);
      EEPROM.put(sizeof(FMem), FOffset);
    }
    Frq = FMem[Mem] / 10;
    SaveVfo = 0;
    NewMemToSave = 0;
    return; 
  }
  if (Menue==10)
  {
    Menue=0;
    return;
  }
  if (Menue<10)
  {
    Menue++;
    if(Menue == 7)
      Menue = 8;
    if(Menue == 9 && Mode == 0) //skip the scan menu in vfo mode
    {
       Menue=0; 
    }
  }
  else 
    Menue=0;
}
 
void WriteFrq (unsigned long int Frq1 ) {
     if (Frq1 < 141000) Frq1 = 141000;
     if (Frq1 > 149990) Frq1 = 149990;
  lcd.setCursor (0,0);
     lcd.print(Frq1/1000);
          lcd.print(".");
          Tmp=Frq1%1000;
          if (Tmp<100)
          lcd.print("0");
          if (Tmp<10)
          lcd.print("0");
          lcd.print(Tmp);
          lcd.setCursor (8,0);
          lcd.print("MHz");

    // Indikasi Shift (+/-)
    lcd.setCursor(12, 0);
    if (Shift < 0) lcd.print("-");
    if (Shift > 0) lcd.print("+");
    if (Shift == 0) lcd.print(" ");

    //Indikasi Tone Aktif
    lcd.setCursor (6,1);
    if(PlSq){
      lcd.write(8);
    } else {
      lcd.print(" ");
    }
    // Mode Memory (M1, M2, dst) atau VFO
    lcd.setCursor(0, 1);
    if (!Mode) {
        lcd.print("    ");
    } else {
        lcd.print("M:");
        lcd.print(Mem);
        if (Mem < 10 ) lcd.print(" ");
    }

    // Indikasi Power (Hi/Lo)
    lcd.setCursor(8, 1);
    if (Power) {
        lcd.print("H");
    } else {
        lcd.print("L");
    }

    // Simbol khusus di pojok kanan
    lcd.setCursor(10, 1);
    lcd.write(6);
}

void WriteMenue() 
{
  // Hapus kedua baris sebelum mengganti tampilan
  lcd.setCursor(0, 0);
  lcd.print("                "); // Hapus baris pertama
  lcd.setCursor(0, 1);
  lcd.print("                "); // Hapus baris kedua

  lcd.setCursor(0, 0); // Kembali ke baris atas setelah menghapus
  
  switch (Menue) {
    case 0:  // VFO Frequency
      WriteFrq(Frq);
      break;

    case 1:  // Mode
      lcd.print("MODE  ");
      lcd.setCursor(0, 1);
      lcd.print(Mode ? "Memory " : "Program    ");
      break;

    case 2:  // Shift
      lcd.print("SHIFT  ");
      lcd.setCursor(0, 1);
      if (Shift == 0) lcd.print("Simplex ");
      else if (Shift == -1) lcd.print("Rpt -   ");
      else if (Shift == 1) lcd.print("Rpt +   ");
      break;

    case 3:  // Tone Squelch
      lcd.print("Tone  ");
      lcd.setCursor(0, 1);
      lcd.print(PlSq ? "Tone " : "None ");
      break;

    case 4:  // CTCSS
      lcd.print("CTCSS ");
      lcd.setCursor(0, 1);
      lcd.print(Ctcss);
      lcd.print(" Hz  ");
      break;

    case 5:  // Step
      lcd.print("VFO Step  ");
      lcd.setCursor(0, 1);
      lcd.print(Step);
      lcd.print("Khz  ");
      break;

    case 6:  // Offset
      lcd.print("Offset ");
      lcd.setCursor(0, 1);
      lcd.print(Offset);
      lcd.print(" KHz ");
      break;

    case 7:  // Save VFO (hanya di Mode VFO)
      if (Mode == 0) {
        lcd.print("Save?  ");
        lcd.setCursor(0, 1);
        lcd.print(SaveVfo ? " Yes  " : " No   ");
      }
      break;

    case 8:  // Power
      lcd.print("Power  ");
      lcd.setCursor(0, 1);
      lcd.print(Power ? " High  " : " Low   ");
      break;

    case 9:  // Scan (hanya di Memory Mode)
      if (Mode == 1) {
        lcd.print("Scan  ");
        lcd.setCursor(0, 1);
        lcd.print(Mem);
      }
      break;
  }
  Curspress = 0; // Reset Cursor Press
}

void saveVfo(){
      if (Mode == 0) {
        lcd.setCursor (0,0);
        lcd.print("Save?  ");
        lcd.setCursor(0, 1);
        lcd.print(SaveVfo ? " Yes  " : " No   ");
        Curspress=0;
      }
}
void exitSave(){
  lcd.clear();
}

void updateFrequency(){
    lcd.setCursor (0,0);
     lcd.print(Frq/1000);
          lcd.print(".");
          Tmp=Frq%1000;
          if (Tmp<100)
          lcd.print("0");
          if (Tmp<10)
          lcd.print("0");
          lcd.print(Tmp);
}
void updatePowerDisplay() {
    lcd.setCursor(8, 1);
    lcd.print(Power ? "H" : "L");
}
void updateModeDisplay() {
    lcd.setCursor(0, 1);
    if (!Mode) {
        lcd.print("    ");
    } else {
        lcd.print("M:");
        lcd.print(Mem);
        if (Mem < 10 ) lcd.print(" ");
    }
}
void addShiftToNewMem()
{
  if(Shift < 0)
    NewMemToSave = Frq * 10 + 3;
  else if(Shift > 0)
    NewMemToSave = Frq * 10 + 5;
  else
    NewMemToSave = Frq * 10 + 1;
  if (PlSq) NewMemToSave |= (1 << 1);
}
void updateDigitPointer(int digit) {
  if (digit == 0){
     lcd.setCursor(2, 1);  lcd.write(7);
     lcd.setCursor(4, 1); lcd.print(" ");
     lcd.setCursor(5, 1); lcd.print(" ");
  }
  else if (digit == 1) {
    lcd.setCursor(4, 1);  lcd.write(7);
    lcd.setCursor(2, 1); lcd.print(" ");
    lcd.setCursor(5, 1); lcd.print(" ");
  }
  else if (digit == 2) {
    lcd.setCursor(5, 1);lcd.write(7);
    lcd.setCursor(2, 1); lcd.print(" ");
    lcd.setCursor(4, 1); lcd.print(" ");
  }
  else {
    return; // -1 artinya tidak ada panah
  }
}

void berubahSignal (){
      lcd.setCursor (13,1); lcd.print (" ");
      lcd.setCursor (14,1); lcd.print (" ");
      lcd.setCursor (15,1); lcd.print (" ");
    
}
void updateSignalRx (){
  unsigned long currentMillis = millis();
  int signal = digitalRead(6);
  int interval = (signal == HIGH) ? riseInterval : fallInterval;

  if (currentMillis - previousMillis >= interval) {
    previousMillis = currentMillis;

    if (signal == HIGH && level < 5) {
      level++;  
    } 
    else if (signal == LOW && level > 0) {
      level--;  
    }
  }
   // Hanya update LCD jika level berubah
  if (level != lastLevel) {
    lastLevel = level; // Simpan nilai terakhir

    for (int i = 0; i < 5; i++) { 
      lcd.setCursor(11 + i, 1);
      if (i < level) {
      lcd.write(byte(i + 1)); // Tampilkan karakter bar graph
      } else {
      lcd.print(' '); // Hapus dengan karakter spasi tunggal
      }
    }
  }     
}
void updateSignalTx (){
  unsigned long currentMillis = millis ();
  int signalTx = digitalRead(7);
  int intervalTx = (Tx == 0) ? riseInterval : fallInterval;

  if (currentMillis - previousMillis >= intervalTx) {
    previousMillis = currentMillis;

    if (Tx==0 && Power && level < 5) {
      level=5;  
    } 
    else if (Tx==0 && level < 2) {
      level=2; 
    } 
    else if (Tx==1 && level >0){
      level--;
    }
  }

  // Hanya update LCD jika level berubah
  if (level != lastLevel) {
    lastLevel = level; // Simpan nilai terakhir

    for (int i = 0; i < 5; i++) { 
      lcd.setCursor(11 + i, 1);
      if (i < level) {
      lcd.write(byte(i + 1)); // Tampilkan karakter bar graph
      } else {
      lcd.print(' '); // Hapus dengan karakter spasi tunggal
      }
  }
  } 
}
void loop(void)
{ 
  //ROTARY ENCODER
  debouncerCLK.update();
  if ( debouncerCLK.fell() ) {
    if (digitalRead(encoder0PinCLK) == digitalRead(encoder0PinDT)) {
    EncDo=-1;
  }else {
    EncDo=1;
  }
  WriteMenue ();
  }
  //TOMBOL EKSTERNAL
  debouncerTB.update(); 
  if (debouncerTB.fell()) { 
    if((Menue !=0) || (Menue ==9)) return;
    Mode = !Mode;  // Toggle Mode antara 0 (VFO) dan 1 (Memory)
    updateModeDisplay(); // Update tampilan setelah Mode berubah
     lcd.setCursor(4, 1); lcd.print(" ");
     lcd.setCursor(5, 1); lcd.print(" ");
  }
  debouncerTB1.update();
  if (debouncerTB1.fell()) { 
    if (Menue !=0) return; 
    if (Mode == 0 || Mode == 1) {  // Bisa berubah di VFO & Memory
        Power = !Power;  // Toggle antara High dan Low
        updatePowerDisplay();  // Perbarui tampilan H/L
    }
  }
  debouncerTB2.update();
  if (debouncerTB2.fell()) {
    if (Menue = !Menue){ //fungsi exit menue dengan tombol
      Mode ==1;
      Menue =0;
    }
    lcd.clear();
    WriteFrq(Frq);
    //Fungsi merubah digit 
    if (Mode==0){
    digitPilihan++;
    if (digitPilihan > 2) digitPilihan = -1;
    updateDigitPointer(digitPilihan);
      }
    }
  //TOMBOL ROTARY
  debouncerSW.update ();
  if(debouncerSW.fell ()) {
    if (Mode == 1 && Menue == 0) {
      Menue = 1;
      WriteMenue();
    } 
    else if (Mode == 0 && Menue == 0) {
      Menue = 7;
      WriteMenue();
    }
    else {
    cursorpress();
    }
}
  Tmp=digitalRead(6);
  if(Rx!=Tmp)
{
  Rx=Tmp;
  if (Rx==1){
  lcd.setCursor ( 14, 0 );
  lcd.print("Rx");
  digitalWrite(5, HIGH);
  }else if (Tx==0) {
    lcd.setCursor(14,0);
    lcd.print("Tx");
    digitalWrite(5, LOW);
  } else if (Menue==1){
    lcd.setCursor(14,0);
    lcd.print("  ");
    digitalWrite(5, LOW);
  }else
  { 
    lcd.setCursor(14,0);
    lcd.print("  ");
    digitalWrite(5, LOW);
  }
  WriteFrq(Frq);
}
  updateSignalRx();

 Tx=digitalRead(7);
 if(Tx!=TxOld) {
  unsigned long TxFreq = Frq;
  set_pll(TxFreq);
  if (Tx==0)
  {
    lcd.setCursor (14, 0);
    lcd.print("Tx");
    Menue=0;
    if (Shift ==1) {
      TxFreq += Offset;
    } else if (Shift ==-1) {
      TxFreq -= Offset;
    }
  }
  else {
  lcd.setCursor (14, 0);
  lcd.print("  ");
  }
  if (Tx==0 && Power) {
    updateSignalTx();
  }
  else if (Tx==0){
    berubahSignal();
  }
  if (Power && Tx == 0) {
    digitalWrite(12, HIGH);  // Aktifkan relay
  } else {
    digitalWrite(12, LOW);   // Matikan relay jika salah satu kondisi tidak terpenuhi
  }
  WriteFrq(TxFreq);
  TxOld=Tx;
 }
  updateSignalTx();


 if(EncDo||0)
  {
    if (Menue == 0) // VFO
  {
  if (!Mode) {
    if (digitPilihan != -1) {
    if (digitPilihan == 0) 
      Frq += (EncDo > 0) ? 1000 : -1000; // Ratusan    } 
    if (digitPilihan == 1) 
      Frq += (EncDo > 0) ? 100 : -100; // Puluhan
    if (digitPilihan == 2) 
      Frq += (EncDo > 0) ? 10 : -10; // Satuan
    } else {
      Frq += EncDo * Step;  // Mode normal kalau digitPilihan = -1
    }
    updateDigitPointer(digitPilihan);
    EncDo = 0;
    if (Frq > 149990) Frq = 141000;
    if (Frq < 141000) Frq = 149990;
    set_pll(Frq);
    updateFrequency();
    addShiftToNewMem();
    }
      else // memory mode
      {
        if(EncDo>0 && Mem< (sizeof (FMem)/4)-1) 
          Mem++;
        else if(EncDo>0)
          Mem=0;
        if((EncDo<0)&&(Mem>0)) 
          Mem--;
        else if(EncDo<0)
          Mem=sizeof (FMem)/4-1;
        EncDo=0; 
      ///////////////////////////////////////////////////////
       Frq=FMem[Mem]/10;
       PlSq = (FMem[Mem] >> 1) & 1;
       Offset = FOffset[Mem];   // ambil offset terpisah
       Tmp=FMem[Mem]%10;
       if(Tmp>4) Shift=1;
       else if (Tmp>2) Shift=-1;
       else Shift=0;
       WriteFrq(Frq);
       set_pll(Frq);
     }
   }
  else if (Menue==1)// Mode
  {
    Mode=!Mode;
    EncDo=0;
    WriteMenue ();
    if(Mode)
    {
      Frq=FMem[Mem]/10;
      PlSq = (FMem[Mem] >> 1) & 1;
      Offset = FOffset[Mem];   // ambil offset terpisah
      Tmp=FMem[Mem]%10;
      if(Tmp>4) Shift=1;
      else if (Tmp>2) Shift=-1;
      else Shift=0;
      set_pll(Frq);
    }
   }
  
  else if (Menue==2)// shift
  {
    if(EncDo>0)
    {
   if(Shift<1)
   Shift++;
   else Shift=-1;
    }
        if(EncDo<0)
    {
   if(Shift>-1)
   Shift--;
   else Shift=1;
    }
    EncDo=0;
    WriteMenue ();
    
  addShiftToNewMem();
} 
  else if (Menue==3)// PL SQUELCH
    {
        PlSq = !PlSq;  // Toggle status PL Squelch
        if (PlSq) {
        setCtcss(Ctcss); // Aktifkan CTCSS dengan frekuensi yang diinginkan
        } else {
        setCtcss(0); // Matikan CTCSS
        }
        EncDo = 0;
        WriteMenue();
    }

  else if (Menue==4){//CTCSS
  if(EncDo>0)
  {
    if (Ctcss==67.0) Ctcss = 71.9;
    else if (Ctcss==71.9) Ctcss=77.0;
    else if (Ctcss==77.0) Ctcss=82.5;
    else if (Ctcss==82.5) Ctcss=88.5;
    else if (Ctcss==88.5) Ctcss=94.8;
    else if (Ctcss==94.8) Ctcss=103.5;
    else if (Ctcss==103.5) Ctcss=110.9;
    else if (Ctcss==110.9) Ctcss=118.8;
    else if (Ctcss==118.8) Ctcss=127.3;
    else if (Ctcss==127.3) Ctcss=136.5;
  }
  if(EncDo<0) {
    if (Ctcss==136.5) Ctcss=127.3;
    else if (Ctcss==127.3) Ctcss=118.8;
    else if (Ctcss==118.8) Ctcss=110.9;
    else if (Ctcss==110.9) Ctcss=103.5;
    else if (Ctcss==103.5) Ctcss=94.8;
    else if (Ctcss==94.8) Ctcss=88.5;
    else if (Ctcss==88.5) Ctcss=82.5;
    else if (Ctcss==82.5) Ctcss=77.0;
    else if (Ctcss==77.0) Ctcss=71.9;
    else if (Ctcss==71.9) Ctcss=67.0;
  }
  EncDo=0;
  WriteMenue ();
  }
  else if (Menue==5)// step
  {
    if(EncDo>0)
    {
      if (Step==10) Step=20;
      else if (Step==20) Step=50;
      else if (Step==50) Step=100;
    }
    if(EncDo<0)
    {
       if (Step==100) Step=50;
       else if (Step==50) Step=20;
       else if (Step==20) Step=10;
    }
    EncDo=0;
    WriteMenue ();
  }
  else if (Menue == 6) { //Offset
     if (EncDo == 1) {
      Offset += Step;
      if (Offset > MaxOffset) Offset=MaxOffset;
  }
  if (EncDo == -1) {
      Offset -= Step;
      if (Offset < MinOffset) Offset=MinOffset;
  }
      EncDo=0;
    WriteMenue();
  }
  else if (Menue==7 && Mode == 0)// save vfo
  {
    SaveVfo =!SaveVfo;
    EncDo=0;
    saveVfo();
  }
  else if (Menue==9 && Mode == 1)// scan
  {
    Scan=1;
    EncDo=0;
    MemBeforeScan = Mem;
    scan();
    WriteMenue(); 
  }
  else if (Menue==8)// POwer
  {
    Power=!Power;
    EncDo=0;
    WriteMenue();
  }
  if (Power && Tx == 0) {
    digitalWrite(12, HIGH);  // Aktifkan relay
  } else {
    digitalWrite(12, LOW);   // Matikan relay jika salah satu kondisi tidak terpenuhi
  }
  }
}
void setCtcss(float freq) { 
    if (freq > 0) {
        uint8_t top = (16000000 / (2 * 32 * freq)) - 1; // Prescaler 32
        OCR2A = top; // Set batas atas

        TCCR2A = (1 << WGM20) | (1 << WGM21) | (1 << COM2A1); // Fast PWM, Non-inverting mode
        TCCR2B = (1 << WGM22) | (1 << CS21) | (1 << CS20); // Prescaler 32
    } else { 
        TCCR2A = 0;
        TCCR2B = 0;
        digitalWrite(11, LOW); // Matikan output
    }
}

void scan()
{
  int Delay1=300;
  while(Scan)
  {
    if( Mem< sizeof (FMem)/4-33) ///// dont want to scan last 32 mem////
      Mem++;
    else Mem=0;
    Frq=FMem[Mem]/10;
    PlSq = (FMem[Mem] >> 1) & 1;
    Tmp=FMem[Mem]%10;
    if(Tmp>4) Shift=1;
    else if (Tmp>2) Shift=-1;
    else Shift=0;
    Offset = FOffset[Mem];   // ambil offset terpisah
    WriteFrq(Frq);
    set_pll(Frq);
    time1=millis();
    Delay1=300;
    while((millis()-time1)<Delay1)
    {
      debouncerCLK.update();
      debouncerSW.update();
      if(digitalRead(6))
      {
        Delay1=5000;
        time1=millis();
      }
      if(!digitalRead(7))
      {
        Scan=0;
        Menue=0;
        return;
      }
      if(debouncerSW.fell())
      {
        Scan=0;
        Menue=0;
        Mem = MemBeforeScan;
        Frq=FMem[Mem]/10;
        PlSq = (FMem[Mem] >> 1) & 1;
        Offset = FOffset[Mem];   // ambil offset terpisah
        WriteFrq(Frq);
        set_pll(Frq);
        return;
      }
    }    
  }
}

