//*Program GM300&&Radius&&Maxtrac/
// *Basic Program dari 4XH1F Avionam Albo
// *Disempurnakan oleh Pecco alamatnya.maspulung@gmail.com/
// *Menggunakan protokol LCD I2C dan Rotary encoder 5Pin/

#include <avr/pgmspace.h>
#include <Bounce2.h>
#include <Wire.h>
#include <LCD_I2C.h>
#include <EEPROM.h>

// Inisialisasi LCD
LCD_I2C lcd(0x27, 16, 2);  // Alamat I2C 0x27, 16x2 LCD
//Rotary Encoder 
#define encoder0PinCLK  4 //encoder
#define encoder0PinDT  3 //encoder
#define encoder0PinSW 2 // for encoder  press
Bounce debouncerCLK = Bounce(); 
Bounce debouncerDT = Bounce(); 
Bounce debouncerSW = Bounce ();
//Kontrol PLL
#define DATA	5		/* Serial Data */
#define CLK	6		/* Serial Clock */
#define LE	7		/* Synthesizer Latch Enable */
#define MAX_MEM 63
//Fungsi Memori
unsigned long int FMem[]={1430001,1430201,1439801,1440601,1450001,1461601,1468001,1471601,1480601,1490801,1429001,1429001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001,1450001};
unsigned long Frq=136000;
unsigned long int NewMemToSave =0;
int FOffset[MAX_MEM];
long FrqFinal;
//Perangkat Pendukung
unsigned long time1;
int EncDo=1;// this changes when you turn the encoder +1 or -1
long Step=5;// vfo step size
int Menue=0; // changes when you scroll the menue
boolean Mode=1; // 0= vfo 1=memory
int Mem=0;// first memory when turn on
boolean Curspress=0;// knows when the encoder was pressed
int Shift=0;// repeater shift register 0= simp// <0 -// >0 +
int CursPos=0;// rotary encoder change
int Tmp=0;// nice to have
float Ctcss = 67.0; 
int Ctcssindex = 0; // Mulai dari 67.0 Hz 
const int CtcssPin = 9;
boolean PlSq=0;// ctcss or cor 0 ctcss 1 cor
boolean Tx=0;// when the rig is in tx it is 0
boolean TxOld=0;// can do without it read insted of reg leave for now....
boolean Rx=0;//indicates the Rx on
boolean Power=0; //output power
unsigned long lastPressTime = 0;  // Waktu terakhir tombol SW ditekan
bool isPressingSW = false;
long Offset = 600;  // Default Offset 600 kHz
long MinOffset = 300;  // Minimum Offset 300 kHz
long MaxOffset = 15000;  // Maximum Offset 15 MHz
boolean SaveVfo = 0;
boolean Scan=0; // temp test scan function
int MemBeforeScan = 0;// return to this frequency when stoping the scan without ptt

// Bar signal untuk kece2an 
int level=0;
int lastLevel=-1;
bool updateDisplay = false; 
unsigned long previousMillis = 0;
const long riseInterval = 30;
const long fallInterval = 80;
byte bar1[8] = { B00000, B00000, B00000, B00000, B00000, B11111, B11111, B11111 }; 
byte bar2[8] = { B00000, B00000, B00000, B00000, B11111, B11111, B11111, B11111 }; 
byte bar3[8] = { B00000, B00000, B00000, B11111, B11111, B11111, B11111, B11111 }; 
byte bar4[8] = { B00000, B00000, B11111, B11111, B11111, B11111, B11111, B11111 }; 
byte bar5[8] = { B00000, B11111, B11111, B11111, B11111, B11111, B11111, B11111 };
byte bar6[8] = { B11111, B11111, B11111, B11111, B11111, B11111, B11111, B11111 }; 
//logo Antenna
byte antenna[8] = {B11111,B10001,B01010,B00100,B00100,B00100,B00100,B00100,};

// Fungsi untuk menyimpan data ke EEPROM
void saveToEEPROM() {
  if(EEPROM[0] == 255 && EEPROM[1] == 255 && EEPROM[2] == 255 && EEPROM[3] == 255)
 {
  // Simpan data FMem ke EEPROM
  EEPROM.put(0, FMem);  // Menyimpan data ke alamat 0
  // Verifikasi apakah data benar-benar tersimpan
  EEPROM.put(sizeof(FMem), FOffset);
 }else{
  // Membaca kembali data
  EEPROM.get (0,FMem);
  EEPROM.get (sizeof(FMem), FOffset);
}
}
void setup()
{
  Serial.begin(9600);
  pinMode(A0, OUTPUT); // ke PTT jika logic board rusak
  pinMode(A1, OUTPUT); // ke PA mute jika logic board rusak 
  pinMode(A2, OUTPUT); // tidak dipakai
  pinMode(A3, INPUT);  // untuk analog bar signal 
  pinMode(A4, OUTPUT); // pin SDA 
  pinMode(A5, OUTPUT); // pin SCL
 debouncerCLK.attach(encoder0PinCLK);
 debouncerCLK.interval(5);
 debouncerDT.attach(encoder0PinDT);
 debouncerDT.interval(5);
 debouncerSW.attach(encoder0PinSW);
 debouncerSW.interval(5);
 saveToEEPROM();

 lcd.begin();
 lcd.backlight();  // Mengaktifkan backlight LCD
 lcd.setCursor(0, 0);
lcd.print("Motorolla-Pecco");
delay(1500);

lcd.clear();  // Bersihkan layar sebelum menampilkan teks selanjutnya
lcd.setCursor(0, 0);
lcd.print("Thanks to");
delay(500);

lcd.clear();
lcd.setCursor(0, 0);

lcd.print("4XH1F"); // Avionam Albo 
delay(500);

lcd.clear();
lcd.setCursor(0, 0);
lcd.print("RudikWid"); //Mas Rudi Ngoprekdirumah YT
delay(500);

lcd.clear();
lcd.setCursor(0, 0);
lcd.print("DediKaping"); // Mas dedik "panji" 406 Malang
delay(500);

lcd.clear();
lcd.setCursor(0, 0);
lcd.print("ChatGPT"); // beberapa kode penyempurnaan berdiskusi dengan openAI 
delay(1500);

lcd.clear();  // Bersihkan layar
  lcd.createChar(0, bar1);
  lcd.createChar(1, bar2);
  lcd.createChar(2, bar3);
  lcd.createChar(3, bar4);
  lcd.createChar(4, bar5);
  lcd.createChar(5, bar6);
  lcd.createChar(6, antenna);
 pinMode (9,OUTPUT);// plsql pin 13 j8 on maxtrac
 pinMode (11,OUTPUT);// power out
 pinMode(encoder0PinCLK, INPUT); // for encoder turn
 pinMode(encoder0PinDT, INPUT); // for encoder turn 2
 pinMode(encoder0PinSW, INPUT_PULLUP); // for encoder  press
 pinMode(8, INPUT); //pttfrom pin 11 j8 on maxtrac
 pinMode(10, INPUT); //Rx indicator from maxtrac
 pinMode (LE, OUTPUT);
 drive_bus (0);
  digitalWrite (LE, LOW);
  digitalWrite (CLK, LOW);
  TIMSK1 = 0;			/* Disable all timer1 interrupts */
  TCCR1A = 0;			/* Normal: Don't drive OC1A/OC1B */
  TCCR1B = _BV(WGM12) | _BV(CS10); /* CTC Mode 4, clk/1 no prescale */
  OCR1A = 888;			/* 889 ticks between interrupts */
}
void set_pll (unsigned long int hz)
{
 unsigned int n;	  /* N is the 10-bit divide-by-127 counter  */
 byte a;		  /* A is the 7-bit remainder counter */
  hz*=1000;
  hz += (45100000 * Tx) - (!Tx * Shift * Offset * 1000 * -1);
  hz /= 5000;	    // Divide by 5KHz reference
  n = hz / 64;  // 127 for UHF
  a = hz - (n * 64);  // 127 for UHF
  drive_bus (1);

  /* Send "(n << 8)|(a << 1)", 24 bits, MSB first, LSB always zero */
  emit_byte ((n >> 8) & 0xFF);	/* N high byte */
  emit_byte (n & 0xFF);		/* N low byte */
  emit_byte (a << 1);		/* A and LSB 0 */
  pulse_le();			/* Latch it */
 
  emit_byte (0x16);		// 0x0901 is R=1152<<1 with LSB flag set but i wanted 5K step so change new settings
  emit_byte (0x81);
  pulse_le();
  drive_bus (0);
}
volatile unsigned long int time = 0;
void drive_bus (byte enable)
{
#if TRACES_CUT
enable = 1;	
#endif

  if (enable) {
    pinMode (DATA, OUTPUT);
    pinMode (CLK, OUTPUT);
    digitalWrite (DATA, HIGH);
  } else {
    pinMode (DATA, INPUT);
    pinMode (CLK, INPUT);
    digitalWrite (DATA, LOW);
  }
}


void emit_byte (byte c)
{
  byte bit;

  for (bit = 0; bit < 8; bit++)
    {
      digitalWrite (DATA, (c & 0x80) ? HIGH : LOW);
      time++;
      time++; 
      digitalWrite (CLK, HIGH);	/* rising edge latches data */
      c <<= 1;			
      time++;
      time++;
      time++;
      digitalWrite (CLK, LOW);
    }
  digitalWrite (DATA, HIGH);
}
void pulse_le (void)
{
  digitalWrite (LE, HIGH);
  time++;			
  time++;
  digitalWrite (LE, LOW);
}
void cursorpress()
{
  Curspress=1;
  if (Mode==1 && Menue==1)
  {
    Menue=8;
    return;
  }
  if(Mode==0 && Menue==0 && NewMemToSave != 0)
  {
    SaveVfo = 0;
    Menue = 7;
    return;
  }
  if(Menue == 7 && Mode == 0)
  {
    Menue = 0;
    Mode = 1;
    if(SaveVfo)
    {
      FMem[Mem] =  NewMemToSave;
      FOffset[Mem] = Offset;
      EEPROM.put(0, FMem);
      EEPROM.put(sizeof(FMem), FOffset);
    }
    Frq = FMem[Mem] / 10;
    SaveVfo = 0;
    NewMemToSave = 0;
    return; 
  }
  if (Menue==10)
  {
    Menue=0;
    return;
  }
  if (Menue<10)
  {
    Menue++;
    if(Menue == 7)
      Menue = 8;
    if(Menue == 9 && Mode == 0) //skip the scan menu in vfo mode
    {
       Menue=0; 
    }
  }
  else 
    Menue=0;
}
 
 void WriteFrq (unsigned long int Frq1)
 {
     lcd.setCursor ( 0, 0 );
    
     lcd.print(Frq1/1000);
          lcd.print(".");
          Tmp=Frq1%1000;
          if (Tmp<100)
          lcd.print("0");
          if (Tmp<10)
          lcd.print("0");
          lcd.print(Tmp);
          lcd.setCursor (8,0);
          lcd.print("MHz");
          lcd.setCursor (12,0);
          if(Shift<0)
          lcd.print("-");
          if(Shift>0)
          lcd.print("+");
          if(Shift==0)
          lcd.print(" ");
          lcd.setCursor (3,1);
          if(PlSq==0)
          lcd.print("T");
          if(PlSq==1)
          lcd.print(" ");
          lcd.setCursor ( 0, 1 );
          if (!Mode)
          lcd.print("    ");
          else
          {
          lcd.print("M");
          lcd.print(Mem);
          if(Mem<10) lcd.print(" ");
        }
        lcd.setCursor(6,1);
        if(Power) {
        lcd.print("Hi");
        }else { lcd.print("Lo");
        }
        lcd.setCursor(10, 1); 
        lcd.write(6); 
 }
 
void WriteMenue() 
{
  // Hapus kedua baris sebelum mengganti tampilan
  lcd.setCursor(0, 0);
  lcd.print("                "); // Hapus baris pertama
  lcd.setCursor(0, 1);
  lcd.print("                "); // Hapus baris kedua

  lcd.setCursor(0, 0); // Kembali ke baris atas setelah menghapus
  
  switch (Menue) {
    case 0:  // VFO Frequency
      WriteFrq(Frq);
      break;

    case 1:  // Mode
      lcd.print("MODE  ");
      lcd.setCursor(0, 1);
      lcd.print(Mode ? "Memory " : "Program    ");
      break;

    case 2:  // Shift
      lcd.print("SHIFT  ");
      lcd.setCursor(0, 1);
      if (Shift == 0) lcd.print("Simplex ");
      else if (Shift == -1) lcd.print("Rpt -   ");
      else if (Shift == 1) lcd.print("Rpt +   ");
      break;

    case 3:  // Tone Squelch
      lcd.print("Tone  ");
      lcd.setCursor(0, 1);
      lcd.print(PlSq ? "Tone " : "None ");
      break;

    case 4:  // CTCSS
      lcd.print("CTCSS ");
      lcd.setCursor(0, 1);
      lcd.print(Ctcss);
      lcd.print(" Hz  ");
      break;

    case 5:  // Step
      lcd.print("VFO Step  ");
      lcd.setCursor(0, 1);
      lcd.print(Step);
      lcd.print("Khz  ");
      break;

    case 6:  // Offset
      lcd.print("Offset ");
      lcd.setCursor(0, 1);
      lcd.print(Offset);
      lcd.print(" KHz ");
      break;

    case 7:  // Save VFO (hanya di Mode VFO)
      if (Mode == 0) {
        lcd.print("Save?  ");
        lcd.setCursor(0, 1);
        lcd.print(SaveVfo ? " Yes  " : " No   ");
      }
      break;

    case 8:  // Power
      lcd.print("Power  ");
      lcd.setCursor(0, 1);
      lcd.print(Power ? " High  " : " Low   ");
      break;

    case 9:  // Scan (hanya di Memory Mode)
      if (Mode == 1) {
        lcd.print("Scan  ");
        lcd.setCursor(0, 1);
        lcd.print(Mem);
      }
      break;
  }
  Curspress = 0; // Reset Cursor Press
}
void saveVfo(){
      if (Mode == 0) {
        lcd.setCursor (0,0);
        lcd.print("Save?  ");
        lcd.setCursor(0, 1);
        lcd.print(SaveVfo ? " Yes  " : " No   ");
        Curspress=0;
      }
}

void addShiftToNewMem()
{
  if(Shift < 0)
    NewMemToSave = Frq * 10 + 3;
  else if(Shift > 0)
    NewMemToSave = Frq * 10 + 5;
  else
    NewMemToSave = Frq * 10 + 1;
    if (PlSq) NewMemToSave |= (1 << 1);
}
 
void loop(void)
{ 
  debouncerCLK.update();
  if ( debouncerCLK.fell() ) {
    if (digitalRead(encoder0PinCLK) == digitalRead(encoder0PinDT)) {
    EncDo=-1;
  }else {
    EncDo=1;
  }
  WriteMenue ();
  }
  debouncerSW.update ();
  if(debouncerSW.fell ()) {
    if (Mode == 1 && Menue == 0) {
      Menue = 1;
      WriteMenue();
    } 
    else if (Mode == 0 && Menue == 0) {
      Menue = 7;
      WriteMenue();
    }
    else {
    cursorpress();
    }
}
  Tmp=digitalRead(10);
  if(Rx!=Tmp)
{
  Rx=Tmp;
  if (Rx==1){
  lcd.setCursor ( 14, 0 );
  lcd.print("Rx");
  lcd.setCursor (13,1);
    digitalWrite(A1, HIGH);
   lcd.setCursor(13,1);
    lcd.write(5);
  }else if (Tx==0) {
    lcd.setCursor(14,0);
    lcd.print("Tx");
    lcd.setCursor(13,1);
    lcd.write(0);
    digitalWrite(A1, LOW);
  } else
  { 
    lcd.setCursor(14,0);
    lcd.print("  ");
    lcd.setCursor(13,1);
    lcd.write(0);
    digitalWrite(A1, LOW);
  }
  WriteFrq(Frq);
}
unsigned long currentMillis = millis();  // Pastikan variabel waktu pakai unsigned long
  int signal = analogRead(A3); // Baca sinyal analog (0-1023)
  int targetLevel = map(signal, 0, 700, 0, 5);
  targetLevel = constrain(targetLevel, 0, 5); // Pastikan dalam batas 0-6
  int interval = (level > lastLevel) ? riseInterval : fallInterval;

  if (targetLevel > level) { 
    if (currentMillis - previousMillis >= riseInterval) { 
      previousMillis = currentMillis;
      level++;
      updateDisplay = true;
    }
  } else if (targetLevel < level) { 
    if (currentMillis - previousMillis >= fallInterval) { 
      previousMillis = currentMillis;
      level--;
      updateDisplay = true;
    }
  }
  // 🔹 Hanya update LCD jika level berubah
  if (updateDisplay && level != lastLevel) {
    updateDisplay = false; // Reset flag
    lastLevel = level; // Simpan nilai terakhir) 
  // 🔹 Hapus area bar graph
  for (int i = 0; i < 6; i++) { 
    lcd.setCursor(11 + i, 1);
    lcd.print("       "); 
  }

  // 🔹 Gambar ulang bar graph
  for (int i = 0; i < level; i++) {
    lcd.setCursor(11 + i, 1);
    lcd.write(i + 1);
  }
  }
  
 Tx=digitalRead(8);
 if(Tx!=TxOld) {
  if (Frq < 136000) Frq = 136000;
  if (Frq > 165000) Frq = 165000;
  unsigned long TxFreq = Frq;
  set_pll(TxFreq);
  lcd.setCursor (14, 0);
  if (Tx==0)
  {
    lcd.print("Tx");
    Menue=0;
    digitalWrite(A0, HIGH);
    if (Shift ==1) {
      TxFreq += Offset;
    } else if (Shift ==-1) {
      TxFreq -= Offset;
    }
  }
  else {
  lcd.print("  ");
  digitalWrite(A0, LOW);
  }
  WriteFrq(TxFreq);
  TxOld=Tx;
 }
  if(EncDo||0)
  {
    if (Menue==0) //VFO
    {
      if(!Mode)// VFO
      {
        if(EncDo>0) Frq=Frq+Step;
        if(EncDo<0) Frq=Frq-Step;
        EncDo=0;
        set_pll(Frq);
        WriteFrq(Frq);
        addShiftToNewMem();
        
      }
      else // memory mode
      {
        if(EncDo>0 && Mem< (sizeof (FMem)/4)-1) 
          Mem++;
        else if(EncDo>0)
          Mem=0;
        if((EncDo<0)&&(Mem>0)) 
          Mem--;
        else if(EncDo<0)
          Mem=sizeof (FMem)/4-1;
        EncDo=0; 
      ///////////////////////////////////////////////////////
       Frq=FMem[Mem]/10;
       PlSq = (FMem[Mem] >> 1) & 1;
       Offset = FOffset[Mem];   // ambil offset terpisah
       Tmp=FMem[Mem]%10;
       if(Tmp>4) Shift=1;
       else if (Tmp>2) Shift=-1;
       else Shift=0;
       WriteFrq(Frq);
       set_pll(Frq);
     }
   }
  else if (Menue==1)// Mode
  {
    Mode=!Mode;
    EncDo=0;
    WriteMenue ();
    if(Mode)
    {
      Frq=FMem[Mem]/10;
      PlSq = (FMem[Mem] >> 1) & 1;
      Offset = FOffset[Mem];   // ambil offset terpisah
      Tmp=FMem[Mem]%10;
      if(Tmp>4) Shift=1;
      else if (Tmp>2) Shift=-1;
      else Shift=0;
      set_pll(Frq);
    }
   }
  
  else if (Menue==2)// shift
  {
    if(EncDo>0)
    {
   if(Shift<1)
   Shift++;
   else Shift=-1;
    }
        if(EncDo<0)
    {
   if(Shift>-1)
   Shift--;
   else Shift=1;
    }
    EncDo=0;
    WriteMenue ();
    
  addShiftToNewMem();
}
  
  else if (Menue==3)// PL SQUELCH
  {
   PlSq=!PlSq;
       EncDo=0;
        digitalWrite(9,Ctcss);
        digitalWrite(9,PlSq);
    WriteMenue ();
  }
  else if (Menue==4){//CTCSS
  if(EncDo>0)
  {
    if (Ctcss==67.0) Ctcss = 71.9;
    else if (Ctcss==71.9) Ctcss=77.0;
    else if (Ctcss==77.0) Ctcss=82.5;
    else if (Ctcss==82.5) Ctcss=88.5;
    else if (Ctcss==88.5) Ctcss=94.8;
    else if (Ctcss==94.8) Ctcss=103.5;
    else if (Ctcss==103.5) Ctcss=110.9;
    else if (Ctcss==110.9) Ctcss=118.8;
    else if (Ctcss==118.8) Ctcss=127.3;
    else if (Ctcss==127.3) Ctcss=136.5;
  }
  if(EncDo<0) {
    if (Ctcss==136.5) Ctcss=127.3;
    else if (Ctcss==127.3) Ctcss=118.8;
    else if (Ctcss==118.8) Ctcss=110.9;
    else if (Ctcss==110.9) Ctcss=103.5;
    else if (Ctcss==103.5) Ctcss=94.8;
    else if (Ctcss==94.8) Ctcss=88.5;
    else if (Ctcss==88.5) Ctcss=82.5;
    else if (Ctcss==82.5) Ctcss=77.0;
    else if (Ctcss==77.0) Ctcss=71.9;
    else if (Ctcss==71.9) Ctcss=67.0;
  }
  EncDo=0;
  WriteMenue ();
  }
  else if (Menue==5)// step
  {
    if(EncDo>0)
    {
      if (Step==2) Step=5;
      else if (Step==5) Step=10;
      else if (Step==10) Step=12;
      else if (Step==12) Step=20;
      else if (Step==20) Step=25;
      else if (Step==25) Step=50;
      else if (Step==50) Step=1000;
    }
    if(EncDo<0)
    {
       if (Step==1000) Step=50;
       else if (Step==50) Step=25;
       else if (Step==25) Step=20;
       else if (Step==20) Step=12;
       else if (Step==12) Step=10;
       else if (Step==10) Step=5;
       else if (Step==5) Step=2;
    }
    EncDo=0;
    WriteMenue ();
  }
  else if (Menue == 6) { //Offset
     if (EncDo == 1) {
      Offset += Step;
      if (Offset > MaxOffset) Offset=MaxOffset;
  }
  if (EncDo == -1) {
      Offset -= Step;
      if (Offset < MinOffset) Offset=MinOffset;
  }
      EncDo=0;
    WriteMenue();
  }
  else if (Menue==7 && Mode == 0)// save vfo
  {
    SaveVfo =!SaveVfo;
    EncDo=0;
    saveVfo();
  }
  else if (Menue==9 && Mode == 1)// scan
  {
    Scan=1;
    EncDo=0;
    MemBeforeScan = Mem;
    scan();
    WriteMenue(); 
  }
  else if (Menue==8)// POwer
  {
    Power=!Power;
    EncDo=0;
    digitalWrite(11,Power);
    WriteMenue();
  }
  }
}

void scan()
{
  int Delay1=300;
  while(Scan)
  {
    if( Mem< sizeof (FMem)/4-33) ///// dont want to scan last 32 mem////
      Mem++;
    else Mem=0;
    Frq=FMem[Mem]/10;
    PlSq = (FMem[Mem] >> 1) & 1;
    Tmp=FMem[Mem]%10;
    if(Tmp>4) Shift=1;
    else if (Tmp>2) Shift=-1;
    else Shift=0;
    Offset = FOffset[Mem];   // ambil offset terpisah
    WriteFrq(Frq);
    set_pll(Frq);
    time1=millis();
    Delay1=300;
    while((millis()-time1)<Delay1)
    {
      debouncerCLK.update();
      if(digitalRead(10))
      {
        Delay1=5000;
        time1=millis();
      }
      if(!digitalRead(8))
      {
        Scan=0;
        Menue=0;
        return;
      }
      if(debouncerSW.fell())
      {
        Scan=0;
        Menue=0;
        Mem = MemBeforeScan;
        Frq=FMem[Mem]/10;
        PlSq = (FMem[Mem] >> 1) & 1;
        Offset = FOffset[Mem];   // ambil offset terpisah
        WriteFrq(Frq);
        set_pll(Frq);
        return;
      }
    }    
  }
}
